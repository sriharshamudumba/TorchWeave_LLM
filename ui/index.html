<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TorchWeave LLM - Model Management & Inference</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #2d3748;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .header {
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }

        .tab-nav {
            background: #f8fafc;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: center;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 20px 30px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            color: #4a5568;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }

        .tab-button.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .tab-button:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .models-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .model-card {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .model-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
        }

        .model-card.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .model-card.loading {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.05);
        }

        .model-card.error {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.05);
        }

        .model-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .model-title {
            font-size: 18px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .model-description {
            font-size: 14px;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .model-meta {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #718096;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .inference-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .input-panel {
            background: #f8fafc;
            padding: 25px;
            border-radius: 15px;
            border: 2px solid #e2e8f0;
        }

        .output-panel {
            background: #1a202c;
            color: #e2e8f0;
            padding: 25px;
            border-radius: 15px;
            min-height: 500px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2d3748;
        }

        input, textarea, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea {
            resize: vertical;
            min-height: 120px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #718096 0%, #4a5568 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status.connected {
            background: #10b981;
            color: white;
        }

        .status.disconnected {
            background: #ef4444;
            color: white;
        }

        .status.loading {
            background: #f59e0b;
            color: white;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .loading-spinner {
            width: 12px;
            height: 12px;
            border: 2px solid currentColor;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .search-section {
            background: #f8fafc;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e2e8f0;
            margin-bottom: 30px;
        }

        .search-controls {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .search-results {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .search-result {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .search-result:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .metrics {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #4a5568;
            flex-wrap: wrap;
        }

        .metric {
            background: rgba(102, 126, 234, 0.1);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
        }

        .output-content {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert.success {
            background: #d1fae5;
            border: 1px solid #10b981;
            color: #065f46;
        }

        .alert.error {
            background: #fee2e2;
            border: 1px solid #ef4444;
            color: #991b1b;
        }

        .alert.warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #92400e;
        }

        @media (max-width: 768px) {
            .models-grid,
            .inference-section {
                grid-template-columns: 1fr;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }

            .search-controls {
                flex-direction: column;
            }

            .status-bar {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>TorchWeave LLM</h1>
            <p>Advanced Model Management & High-Performance Inference</p>
            <div class="status-bar">
                <div class="status disconnected" id="inferenceStatus">
                    <div class="status-indicator"></div>
                    Inference: Offline
                </div>
                <div class="status disconnected" id="modelManagerStatus">
                    <div class="status-indicator"></div>
                    Model Manager: Offline
                </div>
            </div>
        </div>

        <nav class="tab-nav">
            <button class="tab-button active" onclick="showTab('models')">Model Management</button>
            <button class="tab-button" onclick="showTab('inference')">Inference</button>
        </nav>

        <!-- Model Management Tab -->
        <div id="modelsTab" class="tab-content active">
            <!-- Model Search Section -->
            <div class="search-section">
                <h3 style="margin-bottom: 15px;">Search HuggingFace Models</h3>
                <div class="search-controls">
                    <div class="form-group" style="flex: 1; margin-bottom: 0;">
                        <input type="text" id="searchQuery" placeholder="Search for models (e.g., 'microsoft/DialoGPT')" value="">
                    </div>
                    <button class="btn btn-secondary" onclick="searchModels()">Search</button>
                </div>
                <div id="searchResults" class="search-results"></div>
            </div>

            <!-- Current Models -->
            <div class="models-grid">
                <div>
                    <h3 style="margin-bottom: 20px;">Available Models</h3>
                    <div id="modelsList">
                        <div class="alert warning">
                            Loading models...
                        </div>
                    </div>
                    <button class="btn" onclick="showAddModelModal()" style="margin-top: 15px;">
                        Add Custom Model
                    </button>
                </div>

                <div>
                    <h3 style="margin-bottom: 20px;">Model Details</h3>
                    <div id="modelDetails" style="background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 15px; padding: 25px; min-height: 300px;">
                        <p style="color: #718096; text-align: center; margin-top: 100px;">Select a model to view details</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Inference Tab -->
        <div id="inferenceTab" class="tab-content">
            <div id="noModelAlert" class="alert warning" style="display: none;">
                No model loaded. Please load a model from the Model Management tab first.
            </div>

            <div class="inference-section">
                <div class="input-panel">
                    <h3 style="margin-bottom: 20px;">Generation Parameters</h3>
                    
                    <div class="form-group">
                        <label for="prompt">Prompt</label>
                        <textarea id="prompt" placeholder="Enter your prompt here...">Explain the concept of machine learning in simple terms.</textarea>
                    </div>

                    <div class="controls-grid">
                        <div class="form-group">
                            <label for="maxTokens">Max Tokens</label>
                            <input type="number" id="maxTokens" value="128" min="1" max="2048">
                        </div>
                        <div class="form-group">
                            <label for="temperature">Temperature</label>
                            <input type="number" id="temperature" value="0.7" min="0.1" max="2.0" step="0.1">
                        </div>
                    </div>

                    <div class="controls-grid">
                        <div class="form-group">
                            <label for="topK">Top K</label>
                            <input type="number" id="topK" value="50" min="1" max="100">
                        </div>
                        <div class="form-group">
                            <label for="topP">Top P</label>
                            <input type="number" id="topP" value="0.9" min="0.1" max="1.0" step="0.1">
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="endpoint">Inference Mode</label>
                        <select id="endpoint">
                            <option value="/v1/generate">SSE Streaming (Recommended)</option>
                            <option value="/v1/generate_nobatch">Standard (No Batching)</option>
                        </select>
                    </div>

                    <button class="btn" id="generateBtn" onclick="generateText()">
                        Generate Text
                    </button>

                    <button class="btn btn-secondary" onclick="clearOutput()">
                        Clear Output
                    </button>
                </div>

                <div class="output-panel">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3>Generated Output</h3>
                        <div class="status disconnected" id="generationStatus">Ready</div>
                    </div>
                    
                    <div class="output-content" id="output">
Welcome to TorchWeave LLM Interface!

Features:
• Dynamic model loading from HuggingFace
• Real-time SSE token streaming  
• Advanced continuous batching
• Performance metrics & monitoring
• Multi-model support

Load a model from the Model Management tab to get started.
                    </div>

                    <div class="metrics" id="metrics" style="display: none;">
                        <div class="metric">
                            <strong>TTFT:</strong> <span id="ttft">-</span>ms
                        </div>
                        <div class="metric">
                            <strong>Tokens:</strong> <span id="tokenCount">0</span>
                        </div>
                        <div class="metric">
                            <strong>Speed:</strong> <span id="tokensPerSec">-</span> tok/s
                        </div>
                        <div class="metric">
                            <strong>Model:</strong> <span id="currentModel">None</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Model Modal -->
    <div id="addModelModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Add Custom Model</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            
            <div class="form-group">
                <label for="modelId">Model ID</label>
                <input type="text" id="modelId" placeholder="e.g., microsoft/DialoGPT-medium">
            </div>

            <div class="form-group">
                <label for="modelSource">Source</label>
                <select id="modelSource" onchange="toggleSourceFields()">
                    <option value="huggingface">HuggingFace Hub</option>
                    <option value="api">API Endpoint</option>
                </select>
            </div>

            <div class="form-group">
                <label for="displayName">Display Name (Optional)</label>
                <input type="text" id="displayName" placeholder="Custom display name">
            </div>

            <div class="form-group">
                <label for="description">Description (Optional)</label>
                <textarea id="description" placeholder="Model description" rows="3"></textarea>
            </div>

            <div id="apiFields" style="display: none;">
                <div class="form-group">
                    <label for="apiEndpoint">API Endpoint</label>
                    <input type="text" id="apiEndpoint" placeholder="https://api.example.com/v1/chat">
                </div>

                <div class="form-group">
                    <label for="apiKey">API Key (Optional)</label>
                    <input type="password" id="apiKey" placeholder="Your API key">
                </div>
            </div>

            <div style="display: flex; gap: 15px; margin-top: 25px;">
                <button class="btn" onclick="addModel()">Add Model</button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const INFERENCE_API = 'http://localhost:8000';
        const MODEL_MANAGER_API = 'http://localhost:8001';

        // Global state
        let currentEventSource = null;
        let models = [];
        let selectedModel = null;
        let generationMetrics = {
            startTime: null,
            firstTokenTime: null,
            tokenCount: 0
        };

        // Tab management
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName + 'Tab').classList.add('active');
            event.target.classList.add('active');

            // Load data if needed
            if (tabName === 'models') {
                loadModels();
            } else if (tabName === 'inference') {
                checkInferenceReady();
            }
        }

        // Service health checks
        async function checkServices() {
            await checkInferenceService();
            await checkModelManagerService();
        }

        async function checkInferenceService() {
            const statusEl = document.getElementById('inferenceStatus');
            try {
                const response = await fetch(`${INFERENCE_API}/health`);
                if (response.ok) {
                    statusEl.className = 'status connected';
                    statusEl.innerHTML = '<div class="status-indicator"></div>Inference: Online';
                } else {
                    throw new Error('Service unhealthy');
                }
            } catch (error) {
                statusEl.className = 'status disconnected';
                statusEl.innerHTML = '<div class="status-indicator"></div>Inference: Offline';
            }
        }

        async function checkModelManagerService() {
            const statusEl = document.getElementById('modelManagerStatus');
            try {
                const response = await fetch(`${MODEL_MANAGER_API}/health`);
                if (response.ok) {
                    statusEl.className = 'status connected';
                    statusEl.innerHTML = '<div class="status-indicator"></div>Model Manager: Online';
                } else {
                    throw new Error('Service unhealthy');
                }
            } catch (error) {
                statusEl.className = 'status disconnected';
                statusEl.innerHTML = '<div class="status-indicator"></div>Model Manager: Offline';
            }
        }

        // Model management
        async function loadModels() {
            try {
                const response = await fetch(`${MODEL_MANAGER_API}/models`);
                const data = await response.json();
                
                if (data.success) {
                    models = data.data.models;
                    renderModels();
                } else {
                    throw new Error(data.error);
                }
            } catch (error) {
                document.getElementById('modelsList').innerHTML = `
                    <div class="alert error">
                        Failed to load models: ${error.message}
                    </div>
                `;
            }
        }

        function renderModels() {
            const container = document.getElementById('modelsList');
            
            if (models.length === 0) {
                container.innerHTML = `
                    <div class="alert warning">
                        No models loaded. Search and add models from HuggingFace Hub.
                    </div>
                `;
                return;
            }

            container.innerHTML = models.map(model => `
                <div class="model-card ${model.status} ${selectedModel?.model_id === model.model_id ? 'selected' : ''}" 
                     onclick="selectModel('${model.model_id}')">
                    <div class="model-header">
                        <div>
                            <div class="model-title">${model.display_name}</div>
                            <div class="model-description">${model.description}</div>
                        </div>
                        <div class="status ${model.status}">
                            ${model.status === 'loading' ? '<div class="loading-spinner"></div>' : ''}
                            ${model.status}
                        </div>
                    </div>
                    
                    ${model.status === 'loading' && model.progress ? `
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${model.progress}%"></div>
                        </div>
                    ` : ''}
                    
                    <div class="model-meta">
                        <span>Source: ${model.source}</span>
                        ${model.size_mb ? `<span>Size: ${model.size_mb.toFixed(1)} MB</span>` : ''}
                        <span>Added: ${new Date(model.created_at).toLocaleDateString()}</span>
                    </div>
                </div>
            `).join('');
        }

        async function selectModel(modelId) {
            selectedModel = models.find(m => m.model_id === modelId);
            renderModels(); // Re-render to show selection
            showModelDetails(selectedModel);
            
            // Update inference tab
            if (selectedModel.status === 'available') {
                document.getElementById('currentModel').textContent = selectedModel.display_name;
                document.getElementById('noModelAlert').style.display = 'none';
            }
        }

        function showModelDetails(model) {
            const container = document.getElementById('modelDetails');
            
            if (!model) {
                container.innerHTML = '<p style="color: #718096; text-align: center; margin-top: 100px;">Select a model to view details</p>';
                return;
            }

            container.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <h4 style="margin-bottom: 10px;">${model.display_name}</h4>
                    <p style="color: #4a5568; margin-bottom: 15px;">${model.description}</p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                    <div><strong>Status:</strong> <span class="status ${model.status}">${model.status}</span></div>
                    <div><strong>Source:</strong> ${model.source}</div>
                    <div><strong>Model ID:</strong> ${model.model_id}</div>
                    ${model.size_mb ? `<div><strong>Size:</strong> ${model.size_mb.toFixed(1)} MB</div>` : ''}
                </div>

                ${model.tags && model.tags.length > 0 ? `
                    <div style="margin-bottom: 20px;">
                        <strong>Tags:</strong> ${model.tags.map(tag => `<span style="background: #e2e8f0; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-right: 5px;">${tag}</span>`).join('')}
                    </div>
                ` : ''}

                ${model.error_message ? `
                    <div class="alert error">
                        <strong>Error:</strong> ${model.error_message}
                    </div>
                ` : ''}

                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    ${model.status === 'available' ? `
                        <button class="btn btn-small" onclick="useModel('${model.model_id}')">Use for Inference</button>
                    ` : ''}
                    ${model.status === 'error' ? `
                        <button class="btn btn-small" onclick="reloadModel('${model.model_id}')">Retry Load</button>
                    ` : ''}
                    <button class="btn btn-danger btn-small" onclick="deleteModel('${model.model_id}')">Delete</button>
                </div>
            `;
        }

        async function useModel(modelId) {
            showTab('inference');
            // The tab switch will handle updating the UI
        }

        async function deleteModel(modelId) {
            if (!confirm(`Are you sure you want to delete model ${modelId}?`)) return;

            try {
                const response = await fetch(`${MODEL_MANAGER_API}/models/${encodeURIComponent(modelId)}`, {
                    method: 'DELETE'
                });
                const data = await response.json();
                
                if (data.success) {
                    await loadModels();
                    if (selectedModel?.model_id === modelId) {
                        selectedModel = null;
                        showModelDetails(null);
                    }
                } else {
                    alert(`Failed to delete model: ${data.error}`);
                }
            } catch (error) {
                alert(`Failed to delete model: ${error.message}`);
            }
        }

        async function reloadModel(modelId) {
            const model = models.find(m => m.model_id === modelId);
            if (!model) return;

            const modelConfig = {
                model_id: model.model_id,
                source: model.source,
                display_name: model.display_name,
                description: model.description,
                parameters: model.parameters || {},
                tags: model.tags || []
            };

            try {
                const response = await fetch(`${MODEL_MANAGER_API}/models/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model_config: modelConfig,
                        force_reload: true
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    // Start polling for progress
                    pollModelProgress(modelId);
                } else {
                    alert(`Failed to reload model: ${data.error}`);
                }
            } catch (error) {
                alert(`Failed to reload model: ${error.message}`);
            }
        }

        // Model search functionality
        async function searchModels() {
            const query = document.getElementById('searchQuery').value.trim();
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            const resultsContainer = document.getElementById('searchResults');
            resultsContainer.innerHTML = '<div class="alert">Searching models...</div>';

            try {
                const response = await fetch(`${MODEL_MANAGER_API}/models/search/${encodeURIComponent(query)}`);
                const data = await response.json();

                if (data.success && data.data.results.length > 0) {
                    resultsContainer.innerHTML = data.data.results.map(model => `
                        <div class="search-result" onclick="selectSearchResult('${model.id}', '${model.display_name}', '${model.description}')">
                            <div style="font-weight: 600; margin-bottom: 5px;">${model.display_name}</div>
                            <div style="font-size: 12px; color: #4a5568; margin-bottom: 8px;">${model.description}</div>
                            <div style="display: flex; gap: 10px; font-size: 11px; color: #718096;">
                                <span>Downloads: ${model.downloads?.toLocaleString() || 'N/A'}</span>
                                <span>Tags: ${model.tags?.slice(0, 3).join(', ') || 'None'}</span>
                            </div>
                        </div>
                    `).join('');
                } else {
                    resultsContainer.innerHTML = '<div class="alert warning">No models found for your query.</div>';
                }
            } catch (error) {
                resultsContainer.innerHTML = `<div class="alert error">Search failed: ${error.message}</div>`;
            }
        }

        function selectSearchResult(modelId, displayName, description) {
            document.getElementById('modelId').value = modelId;
            document.getElementById('displayName').value = displayName;
            document.getElementById('description').value = description;
            showAddModelModal();
        }

        // Modal management
        function showAddModelModal() {
            document.getElementById('addModelModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('addModelModal').style.display = 'none';
            // Clear form
            document.getElementById('modelId').value = '';
            document.getElementById('displayName').value = '';
            document.getElementById('description').value = '';
            document.getElementById('apiEndpoint').value = '';
            document.getElementById('apiKey').value = '';
            document.getElementById('modelSource').value = 'huggingface';
            toggleSourceFields();
        }

        function toggleSourceFields() {
            const source = document.getElementById('modelSource').value;
            const apiFields = document.getElementById('apiFields');
            apiFields.style.display = source === 'api' ? 'block' : 'none';
        }

        async function addModel() {
            const modelId = document.getElementById('modelId').value.trim();
            const source = document.getElementById('modelSource').value;
            const displayName = document.getElementById('displayName').value.trim();
            const description = document.getElementById('description').value.trim();
            const apiEndpoint = document.getElementById('apiEndpoint').value.trim();
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!modelId) {
                alert('Model ID is required');
                return;
            }

            if (source === 'api' && !apiEndpoint) {
                alert('API endpoint is required for API models');
                return;
            }

            const modelConfig = {
                model_id: modelId,
                source: source,
                display_name: displayName || modelId,
                description: description || `${source} model: ${modelId}`,
                parameters: {},
                tags: [source]
            };

            if (source === 'api') {
                modelConfig.api_endpoint = apiEndpoint;
                if (apiKey) modelConfig.api_key = apiKey;
            }

            try {
                const response = await fetch(`${MODEL_MANAGER_API}/models/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_config: modelConfig })
                });

                const data = await response.json();
                if (data.success) {
                    closeModal();
                    await loadModels();
                    // Start polling for progress
                    pollModelProgress(modelId);
                } else {
                    alert(`Failed to add model: ${data.error}`);
                }
            } catch (error) {
                alert(`Failed to add model: ${error.message}`);
            }
        }

        async function pollModelProgress(modelId) {
            const pollInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${MODEL_MANAGER_API}/models/${encodeURIComponent(modelId)}/progress`);
                    const data = await response.json();
                    
                    if (data.success) {
                        const progress = data.data.progress;
                        
                        // Update model in local array
                        const modelIndex = models.findIndex(m => m.model_id === modelId);
                        if (modelIndex !== -1) {
                            models[modelIndex].progress = progress;
                            if (progress >= 100 || data.data.status === 'available') {
                                models[modelIndex].status = 'available';
                                clearInterval(pollInterval);
                            }
                            renderModels();
                            if (selectedModel?.model_id === modelId) {
                                showModelDetails(models[modelIndex]);
                            }
                        }
                    } else {
                        clearInterval(pollInterval);
                    }
                } catch (error) {
                    console.error('Progress polling failed:', error);
                    clearInterval(pollInterval);
                }
            }, 2000); // Poll every 2 seconds

            // Stop polling after 10 minutes max
            setTimeout(() => clearInterval(pollInterval), 600000);
        }

        // Inference functionality
        function checkInferenceReady() {
            const hasAvailableModel = models.some(m => m.status === 'available');
            const alertEl = document.getElementById('noModelAlert');
            
            if (!hasAvailableModel) {
                alertEl.style.display = 'block';
            } else {
                alertEl.style.display = 'none';
                if (!selectedModel || selectedModel.status !== 'available') {
                    // Auto-select first available model
                    const availableModel = models.find(m => m.status === 'available');
                    if (availableModel) {
                        selectedModel = availableModel;
                        document.getElementById('currentModel').textContent = availableModel.display_name;
                    }
                }
            }
        }

        async function generateText() {
            if (!selectedModel || selectedModel.status !== 'available') {
                alert('Please load a model first from the Model Management tab');
                return;
            }

            const prompt = document.getElementById('prompt').value.trim();
            if (!prompt) {
                alert('Please enter a prompt');
                return;
            }

            // Reset metrics
            generationMetrics = {
                startTime: Date.now(),
                firstTokenTime: null,
                tokenCount: 0
            };

            const generateBtn = document.getElementById('generateBtn');
            const outputEl = document.getElementById('output');
            const metricsEl = document.getElementById('metrics');
            const statusEl = document.getElementById('generationStatus');

            generateBtn.disabled = true;
            generateBtn.innerHTML = 'Generating... <div class="loading-spinner"></div>';
            metricsEl.style.display = 'flex';

            const maxTokens = parseInt(document.getElementById('maxTokens').value);
            const temperature = parseFloat(document.getElementById('temperature').value);
            const topK = parseInt(document.getElementById('topK').value);
            const topP = parseFloat(document.getElementById('topP').value);
            const endpoint = document.getElementById('endpoint').value;

            if (endpoint === '/v1/generate') {
                // SSE Streaming
                statusEl.className = 'status loading';
                statusEl.innerHTML = '<div class="loading-spinner"></div>Streaming';
                outputEl.textContent = '';

                try {
                    const params = new URLSearchParams({
                        prompt: prompt,
                        max_new_tokens: maxTokens.toString(),
                        temperature: temperature.toString(),
                        top_k: topK.toString(),
                        top_p: topP.toString()
                    });

                    currentEventSource = new EventSource(`${INFERENCE_API}${endpoint}?${params}`);

                    currentEventSource.onopen = function() {
                        statusEl.className = 'status connected';
                        statusEl.innerHTML = '<div class="status-indicator"></div>Streaming';
                    };

                    currentEventSource.onmessage = function(event) {
                        if (!generationMetrics.firstTokenTime) {
                            generationMetrics.firstTokenTime = Date.now();
                        }
                        
                        const token = event.data;
                        if (token && token !== '[DONE]') {
                            outputEl.textContent += token;
                            generationMetrics.tokenCount++;
                            updateMetrics();
                        }
                    };

                    currentEventSource.addEventListener('done', function() {
                        statusEl.className = 'status disconnected';
                        statusEl.textContent = 'Complete';
                        currentEventSource.close();
                        currentEventSource = null;
                        generateBtn.disabled = false;
                        generateBtn.textContent = 'Generate Text';
                    });

                    currentEventSource.onerror = function() {
                        statusEl.className = 'status disconnected';
                        statusEl.textContent = 'Error';
                        outputEl.textContent = 'Error connecting to inference server. Please check if TorchWeave is running.';
                        currentEventSource.close();
                        currentEventSource = null;
                        generateBtn.disabled = false;
                        generateBtn.textContent = 'Generate Text';
                    };

                } catch (error) {
                    statusEl.className = 'status disconnected';
                    statusEl.textContent = 'Error';
                    outputEl.textContent = 'Error: ' + error.message;
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Text';
                }
            } else {
                // Standard API
                statusEl.className = 'status loading';
                statusEl.innerHTML = '<div class="loading-spinner"></div>Processing';

                try {
                    const response = await fetch(`${INFERENCE_API}${endpoint}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            prompt: prompt,
                            max_new_tokens: maxTokens,
                            temperature: temperature,
                            top_k: topK,
                            top_p: topP
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    generationMetrics.firstTokenTime = Date.now();
                    generationMetrics.tokenCount = data.text ? data.text.split(/\s+/).length : 0;
                    
                    outputEl.textContent = data.text || 'No response received';
                    statusEl.className = 'status disconnected';
                    statusEl.textContent = 'Complete';
                    updateMetrics();

                } catch (error) {
                    statusEl.className = 'status disconnected';
                    statusEl.textContent = 'Error';
                    outputEl.textContent = `Error: ${error.message}\n\nPlease ensure TorchWeave inference server is running.`;
                }

                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Text';
            }
        }

        function updateMetrics() {
            if (!generationMetrics.startTime) return;

            const now = Date.now();
            const ttft = generationMetrics.firstTokenTime ? 
                generationMetrics.firstTokenTime - generationMetrics.startTime : null;
            const elapsed = (now - generationMetrics.startTime) / 1000;
            const tokensPerSec = elapsed > 0 ? (generationMetrics.tokenCount / elapsed).toFixed(2) : '0';

            document.getElementById('ttft').textContent = ttft ? `${ttft}` : '-';
            document.getElementById('tokenCount').textContent = generationMetrics.tokenCount;
            document.getElementById('tokensPerSec').textContent = tokensPerSec;
        }

        function clearOutput() {
            document.getElementById('output').textContent = 'Output cleared. Ready for new generation.';
            document.getElementById('metrics').style.display = 'none';
            document.getElementById('generationStatus').className = 'status disconnected';
            document.getElementById('generationStatus').textContent = 'Ready';

            if (currentEventSource) {
                currentEventSource.close();
                currentEventSource = null;
            }

            generationMetrics = {
                startTime: null,
                firstTokenTime: null,
                tokenCount: 0
            };
        }

        // Event listeners
        document.getElementById('searchQuery').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchModels();
            }
        });

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('addModelModal');
            if (event.target == modal) {
                closeModal();
            }
        }

        // Initialize application
        async function initialize() {
            await checkServices();
            await loadModels();
            
            // Set up periodic health checks
            setInterval(checkServices, 30000); // Check every 30 seconds
            
            // Auto-refresh models every 5 minutes
            setInterval(loadModels, 300000);
        }

        // Start the application
        initialize();
    </script>
</body>
</html>
